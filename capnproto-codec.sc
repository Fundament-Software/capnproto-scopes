#   capnproto-codec: Utility library used by scopes code generated by capnp-scopes
    Copyright (c)2022 Fundament Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

using import struct
using import enum
using import Array
using import C.stdio
using import itertools

spice show-type (val)
    print ('typeof val)
    val
run-stage;

let capword = u64

type SegmentInterface
    inline get (self n element)
        let base size = (unpack (storagecast self))
        if (n as usize + (sizeof element) >= size * (sizeof capword))
            0 as element
        else 
            copy
                @
                    inttoptr 
                        (ptrtoint base intptr) + n as usize
                        @ element

type Segment < SegmentInterface :: (tuple (mutable (pointer capword)) usize)
    inline __typecall (cls count buff)
        bitcast (tupleof buff (count as usize)) cls

    inline __@ (self idx)
        idx as:= usize
        let base size = (unpack (storagecast self))
        assert (idx < size) "index out of bounds"
        base @ idx


type Owned-Segment <:: Segment
    inline __typecall (cls count)
        let buff = (malloc-array capword count)
        for i in (range count)
            (@ buff i) = 0
        bitcast (tupleof buff (count as usize)) cls

    inline __@ (self idx)
        idx as:= usize
        let base size = (unpack (storagecast self))
        assert (idx < size) "index out of bounds"
        base @ idx

    inline __drop (self)
        returning void
        let base size = (unpack (storagecast self))
        free base
        _;

enum Pointer
    Null
    Struct : u32 u16 u16 u32
    List : u32 i8 u32 u32
    Far : bool u32 u32
    Capability : u32

    # Our pointer object stores more information than just a capnproto pointer. We also store the section index the
    # pointer is from, and the word offset (position) of the pointer in that section, provided the pointer is either
    # a struct pointer or a list pointer. Far pointers and capabilities ignore the segment and position parameters.
    fn... from-word (word : capword, segment : u32, position : u32)
        switch (word & 3)
        case 0
            if (0 == word)
                this-type.Null;
            else
                this-type.Struct
                    ((word & 0xFFFFFFFF) as i32 >> 2) as u32 + position + 1
                    ((word >> 32) & 0xFFFF) as u16
                    (word >> 48) as u16
                    segment
        case 1
            this-type.List
                ((word & 0xFFFFFFFF) as i32 >> 2) as u32 + position + 1
                ((word >> 32) & 7) as i8
                (word >> 35) as u32
                segment
        case 2
            this-type.Far
                ((word >> 2) & 1) as bool
                ((word & 0xFFFFFFFF) >> 3) as u32
                (word >> 32) as u32
        case 3
            if (0 == (word & 0xFFFFFFFC))
                this-type.Capability
                    (word >> 32) as u32
            else
                error "Unimplemented pointer type!"
        default
            unreachable;
    
    fn... to-word (self : this-type, position : u32)
        dispatch self
        case Null ()
            0:u64
        case Struct (offset data-size pointer-size segment)
            0:u64 | (((offset - position - 1) << 2) as u64) | (data-size as u64 << 32) | (pointer-size as u64 << 48)
        case List (offset element-size list-size segment)
            1:u64 | (((offset - position - 1) << 2) as u64) | (element-size as u64 << 32) | (list-size as u64 << 35)
        case Far (landing-size offset segment)
            2:u64 | (landing-size as u64 << 2) | ((offset << 3) as u64) | (segment as u64 << 32)
        case Capability (index)
            3:u64 | (index as u64 << 32)
        default
            unreachable;


struct Message 
    segments : (GrowingArray Owned-Segment)

    fn from-file (file)
        local n : u32 = 0
        fread (& n) (sizeof u32) 1 file
        n += 1
        let sizes = (malloc-array u32 n)
        fread sizes (sizeof u32) n file
        if (n % 2 == 0)
            fseek file (sizeof u32) SEEK_CUR

        local segmentlist = ((GrowingArray Owned-Segment))
        for i in (range n)
            let segment = (Owned-Segment (@ sizes i))
            let base size = (unpack (storagecast (view segment)))
            fread base (sizeof capword) size file
            'append segmentlist segment
        
        this-type
            segmentlist

    inline getRoot (message)
        let word = ((message.segments @ 0) @ 0)
        Pointer.from-word word 0 0

    inline get (message base offset element)
        static-match element
        case void
            _;
        case Pointer
            error "not implemented!"
        default 
            local typelist = (arrayof type i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 bool)

            let isvalid = 
                ->> typelist 
                    map
                        inline "element_compare" (x) (x == i8)
                    reduce false |
            
            if (not isvalid)
                error "Invalid type passed in to get!"

            # the offset is always given as a multiple of the element size. This means we need special handling for 1-bit bools.
            let size = (sizeof element)

            loop (curbase = (view base))
                dispatch (view curbase)
                case Struct (position data-size pointer-size segment)
                    static-if (element == bool)
                        let byte-offset = ((position * (sizeof capword)) + (offset // 8))
                        let bit-offset = (offset % 8)
                        break (((('get (message.segments @ segment) byte-offset u8) & (1 << bit-offset)) != 0) as element)
                    else
                        let location = ((position * (sizeof capword)) + (offset * size))
                        break ('get (message.segments @ segment) location element)
                case List (position element-size list-size segment)
                    vvv break
                    match element-size
                    case 0
                        0 as element
                    case 1
                        if offset >= list-size
                            error "out of bounds list access"
                        
                        let byte-offset = ((position * (sizeof capword)) + (offset // 8))
                        let bit-offset = (offset % 8)
                        (((('get (message.segments @ segment) byte-offset u8) & (1 << bit-offset)) != 0) as element)
                    case 6
                        error "not implemented!"
                    case 7
                        let tag = (Pointer.from-word ('get (message.segments @ segment) (position * (sizeof capword)) u8) 0 0)
                        
                        dispatch (view tag)
                        case Struct (element-count arg1 arg2 arg3)
                            if offset > element-count
                                error "out of bounds list access"
                            
                            let element-bytes = (list-size // element-count)

                            if element-bytes != size
                                error "element-bytes does not equal (sizeof element)!" 

                            let location = (((position + 1) * (sizeof capword)) + (offset * element-bytes) as i64)
                            ('get (message.segments @ segment) location element)
                        default
                            error "Illegal tag pointer"
                    default
                        if element-size > 7
                            error "Illegal encoding"
                        elseif offset >= list-size
                            error "out of bounds list access"
                        else
                            let element-bytes = ((1 << (element-size - 2)) as u32)

                            if element-bytes != size
                                error "element-bytes does not equal (sizeof element)!"
                            
                            let location = ((position * (sizeof capword)) + (offset * element-bytes) as i64)
                            ('get (message.segments @ segment) location element)
                #case Far (word-size offset segment)
                #    if word-size == false
                #        let pos = (offset * (sizeof capword))
                #        let ptr = (Pointer.from-word ('get (message.segments @ segment) pos capword) segment pos)
                #        repeat ptr
                #    else
                #        error "not implemented!"
                case Capability (index)
                    error "not implemented!"
                default
                    unreachable;

locals;
