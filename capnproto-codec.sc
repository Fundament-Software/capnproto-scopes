#   capnproto-codec: Utility library used by scopes code generated by capnp-scopes
    Copyright (c)2022 Fundament Software

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

using import struct
using import enum
using import Array
using import C.stdio
using import itertools
let capword = u64

type Segment :: (tuple (mutable (pointer capword)) usize)
    inline __typecall (cls count buff)
        bitcast (tupleof buff (count as usize)) cls

    inline __@ (self idx)
        idx as:= usize
        let base size = (unpack (storagecast self))
        assert (idx < size) "index out of bounds"
        base @ idx

    inline get (self n element)
        let base size = (unpack (storagecast self))
        if (n + (sizeof element) >= size * (sizeof capword))
            0 as element
        else 
            copy
                @
                    inttoptr 
                        (ptrtoint base intptr) + n
                        @ element

type Owned-Segment <: Segment
    inline __typecall (cls count)
        let buff = (malloc-array capword count)
        for i in (range count)
            (@ buff i) = 0
        bitcast (tupleof buff (count as usize)) cls

    inline __@ (self idx)
        idx as:= usize
        let base size = (unpack (storagecast self))
        assert (idx < size) "index out of bounds"
        base @ idx

    inline __drop (self)
        returning void
        let base size = (unpack (storagecast self))
        free base
        _;

    inline get (self n element)
        let base size = (unpack (storagecast self))
        if (n + (sizeof element) >= size * (sizeof capword))
            0 as element
        else 
            copy
                @
                    inttoptr 
                        (ptrtoint base intptr) + n
                        @ element

enum Pointer 
    Struct : u32 u16 u16 u32
    List : u32 i8 u32 u32
    Far : bool i32 u32
    Capability : u32

    fn... from-word (word : capword, segment : u32, position : u32)
        let a = (word >> 62)
        switch a 
        case 0
            this-type.Struct 
                ((position as i64) + ((((word & 0x3FFFFFFF00000000) >> 30) as i32) >> 2)) as u32
                ((word & 0x00000000FFFF0000) >> 16) as u16
                (word & 0x000000000000FFFF) as u16
                segment
        case 1
            this-type.List 
                ((position as i64) + ((((word & 0x3FFFFFFF00000000) >> 30) as i32) >> 2)) as u32
                ((word & 0x00000000E0000000) >> 29) as i8
                (word & 0x000000001FFFFFFF) as u32
                segment
        case 2
            this-type.Far 
                ((word & 0x2000000000000000) >> 61) as bool
                (((word & 0x1FFFFFFF00000000) >> 29) as i32) >> 3
                (word & 0x00000000FFFFFFFF) as u32
        case 3
            this-type.Capability 
                (word & 0x00000000FFFFFFFF) as u32
        default
            unreachable;
    
    fn to-word (self)
        dispatch self
        case Struct (offset data-size pointer-size segment)
            0 << 62 | (offset as u32 << 32) | (data-size << 16) | pointer-size
        case List (offset element-size list-size segment)
            1 << 62 | (offset as u32 << 32) | (element-size << 29) | list-size
        case Far (word-size offset segment)
            2 << 62 | (word-size << 61) | offset << 32 | segment
        case Capability (size)
            3 << 62 | size
        default
            unreachable;

struct Message 
    segments : (GrowingArray Owned-Segment)

    fn from-fd (fd)
        local n : u32 = 0
        (fread (& n) (sizeof u32) 1 fd)
        n += 1
        let sizes = (malloc-array u32 n)
        (fread sizes (sizeof u32) n fd)
        if (n % 2 == 0)
            (fseek fd (sizeof u32) SEEK_CUR)

        local segmentlist = ((GrowingArray Owned-Segment))
        for i in (range n)
            let segment = (Owned-Segment (@ sizes i))
            let base size = (unpack (storagecast segment))
            (fread base (sizeof capword) size fd)
            'append segmentlist segment
        
        this-type
            segmentlist
    
    inline getRoot (message)
        let word = ((message.segments @ 0) @ 0)
        Pointer.from-word word 0 0

    inline get (message base offset element)
        static-match element
        case void
            _;
        case bool

        case Pointer
            unreachable;
        default 
            local typelist = (arrayof type i8 i16 i32 i64 u8 u16 u32 u64 f32 f64)

            let isvalid = 
                ->> typelist 
                    map
                        inline "element_compare" (x) (x == i8)
                    reduce false |
            
            if (not isvalid)
                error "Invalid type passed in to get!"

            let size = (sizeof element)

            dispatch (view base)
            case Struct (position data-size pointer-size segment)
                let location = ((position * (sizeof capword)) + (offset * size))
                'get (message.segments @ segment) location element
            case List (position element-size list-size segment)
                0 as element
            case Far (word-size offset segment)
                0 as element
            case Capability (size)
                error "??????????"
            default
                unreachable;

locals;